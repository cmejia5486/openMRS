name: Security Scans

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
    
jobs:
  trivy-scan:
    name: Trivy File System Scan (genera payload para IA)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # 1) Ejecuta Trivy y guarda salida JSON en disco (no rompe el job)
      - name: Run Trivy vulnerability scanner (JSON)
        uses: aquasecurity/trivy-action@0.31.0
        with:
          scan-type: fs
          scan-ref: .
          scanners: vuln
          vuln-type: library
          format: json
          output: trivy.json
          exit-code: '0'           # deja al job de IA decidir
          ignore-unfixed: true     # opcional: reduce ruido

      # 2) Metadatos útiles (URL del run, versión Trivy si está disponible)
      - name: Collect meta
        id: meta
        shell: bash
        run: |
          echo "run_url=https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> "$GITHUB_OUTPUT"
          trivy_version=$(trivy --version 2>/dev/null | head -n1 | awk '{print $2}')
          echo "trivy_version=${trivy_version:-unknown}" >> "$GITHUB_OUTPUT"

      # 3) Construye un payload rico para IA (con resumen y detalles)
      - name: Build AI payload (agent_payload.json)
        shell: bash
        run: |
          NOW=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          jq -n \
            --arg repo "${{ github.repository }}" \
            --arg sha "${{ github.sha }}" \
            --arg ref "${{ github.ref }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg run_url "${{ steps.meta.outputs.run_url }}" \
            --arg trivy_version "${{ steps.meta.outputs.trivy_version }}" \
            --arg ts "$NOW" \
            --slurpfile trivy trivy.json \
            'def ensure_results: ($trivy[0].Results // []);
             def to_findings:
               ( ensure_results
                 | map(. as $r
                     | ($r.Vulnerabilities // [])
                     | map({
                         target: $r.Target,
                         class: $r.Class,
                         type:  $r.Type,
                         id: .VulnerabilityID,
                         pkg: .PkgName,
                         installed: .InstalledVersion,
                         fixed: (.FixedVersion // null),
                         fix_available: ( has("FixedVersion") and (.FixedVersion != null) and (.FixedVersion != "") ),
                         severity: .Severity,
                         severity_source: .SeveritySource,
                         vendor_severity: (.VendorSeverity // {}),
                         cvss: ((.CVSS // {}) | to_entries
                                | map({source: .key,
                                       v2: (.value.V2Score // null),
                                       v2_vector: (.value.V2Vector // null),
                                       v3: (.value.V3Score // null),
                                       v3_vector: (.value.V3Vector // null)})),
                         best_cvss:
                           (((.CVSS // {}) | to_entries
                             | map({source: .key,
                                    v3: (.value.V3Score // 0),
                                    v3_vector: (.value.V3Vector // null)})
                             | sort_by(-.v3) | .[0]) // {}),
                         cwe: (.CWEIDs // []),
                         title: .Title,
                         description: (.Description // null),
                         references: (.References // []),
                         published: (.PublishedDate // null),
                         modified: (.LastModifiedDate // null),
                         data_source: (.DataSource // {})
                       })
                   )
                 | add // [] );

             def sev_init: {"CRITICAL":0,"HIGH":0,"MEDIUM":0,"LOW":0,"UNKNOWN":0};

             def summarize($f):
               {
                 total: ($f | length),
                 by_severity: (reduce $f[] as $x (sev_init; .[$x.severity] += 1)),
                 fixable: {
                   total: ($f | map(select(.fix_available)) | length),
                   by_severity: (reduce ($f | map(select(.fix_available))[]) as $x (sev_init; .[$x.severity] += 1))
                 },
                 unique_vulns: ($f | map(.id) | unique | length),
                 packages_affected: ($f | map(.pkg) | unique | length),
                 highest_cvss_v3: ($f | map(.best_cvss.v3 // 0) | max // 0),
                 top_packages: (
                   $f | group_by(.pkg) | map({pkg: .[0].pkg, count: length}) | sort_by(-.count) | .[:10]
                 ),
                 by_target: (
                   $f | group_by(.target)
                      | map({
                          target: .[0].target,
                          total: length,
                          by_severity: (reduce .[] as $x (sev_init; .[$x.severity] += 1)),
                          fixable: (map(select(.fix_available)) | length)
                        })
                 )
               };

             def policy_hints($f):
               {
                 has_critical: any($f[]; .severity=="CRITICAL"),
                 has_high_without_fix: any($f[]; .severity=="HIGH" and (.fix_available|not)),
                 oldest_published_days:
                   ( if ($f|length)==0 then null
                     else ( [ $f[] | select(.published!=null) | (.published | fromdateiso8601) ]
                            | min as $min | (now - $min) / 86400 | floor )
                     end )
               };

             (to_findings) as $F
             |
             {
               meta: { repo: $repo, sha: $sha, ref: $ref, run_id: $run_id, run_url: $run_url, generated_at: $ts },
               scan: { tool: "trivy", tool_version: $trivy_version, mode: "fs", schema: "custom:v2" },
               summary: summarize($F),
               policy_hints: policy_hints($F),
               findings: $F
             }' > agent_payload.json

      # 4) Publica el payload como artifact (consumido por tu job de IA)
      - name: Upload artifact (payload para IA)
        uses: actions/upload-artifact@v4
        with:
          name: trivy-payload
          path: agent_payload.json
          retention-days: 14
