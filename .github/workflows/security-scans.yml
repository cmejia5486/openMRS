name: Security Scans (Trivy → artifact JSON)

on:
  workflow_call:
  #push:
   # branches: [ main ]
  #pull_request:
   # branches: [ main ]
   #
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  trivy-scan:
    name: trivy-scan
    # No ejecutes si el actor es Dependabot o la rama del PR es dependabot/*
    if: ${{ github.actor != 'dependabot[bot]' && !startsWith(github.head_ref || github.ref_name || '', 'dependabot/') && (github.event_name != 'pull_request' || github.event.pull_request.user.login != 'dependabot[bot]') }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # (OPCIONAL, pero recomendado para Gradle)
      # Genera gradle.lockfile sin compilar; mejora la resolución de dependencias para el escaneo
      - name: Generate Gradle lockfile (no build)
        if: ${{ hashFiles('**/gradle.lockfile') == '' }}
        uses: actions/setup-java@v4
        with:
            distribution: temurin
            java-version: '11'
        # Ejecuta resolución de dependencias y escribe locks; no rompe si no hay Gradle
      - name: Write Gradle dependency locks
        run: |
          if [ -f "./gradlew" ]; then
            chmod +x gradlew
            ./gradlew dependencies --write-locks || true
          fi

      # 1) Ejecuta Trivy y guarda salida JSON en disco (no rompe el job)
      - name: Run Trivy vulnerability scanner (JSON)
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: fs          # escaneo del filesystem del repo
          scan-ref: .            # raíz del repo
          scanners: vuln         # solo vulnerabilidades (no secrets/misconfig)
          vuln-type: library     # dependencias de la app (no OS)
          format: json
          output: trivy.json
          exit-code: '0'         # no falla el job: dejamos a la IA decidir

      # 2) Metadatos útiles (URL del run, versión Trivy)
      - name: Collect meta
        id: meta
        shell: bash
        run: |
          echo "run_url=https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> "$GITHUB_OUTPUT"
          trivy_version=$(trivy --version 2>/dev/null | head -n1 | awk '{print $2}')
          echo "trivy_version=${trivy_version:-unknown}" >> "$GITHUB_OUTPUT"

      - name: Ensure jq
        run: sudo apt-get update && sudo apt-get install -y jq

      # 3) Construye un payload rico para IA (con resumen y detalles)
      - name: Build AI payload (agent_payload.json)
        shell: bash
        run: |
          NOW=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          jq -n \
            --arg repo "${{ github.repository }}" \
            --arg sha "${{ github.sha }}" \
            --arg ref "${{ github.ref }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg run_url "${{ steps.meta.outputs.run_url }}" \
            --arg trivy_version "${{ steps.meta.outputs.trivy_version }}" \
            --arg ts "$NOW" \
            --slurpfile trivy trivy.json \
            'def ensure_results: ($trivy[0].Results // []);
             def to_findings:
               ( ensure_results
                 | map(. as $r
                     | ($r.Vulnerabilities // [])
                     | map({
                         target: $r.Target,
                         class:  $r.Class,
                         type:   $r.Type,
                         id: .VulnerabilityID,
                         pkg: .PkgName,
                         installed: .InstalledVersion,
                         fixed: (.FixedVersion // null),
                         fix_available: ( has("FixedVersion") and (.FixedVersion != null) and (.FixedVersion != "") ),
                         severity: .Severity,
                         severity_source: .SeveritySource,
                         vendor_severity: (.VendorSeverity // {}),
                         cvss: ((.CVSS // {}) | to_entries
                                | map({source: .key,
                                       v2: (.value.V2Score // null),
                                       v2_vector: (.value.V2Vector // null),
                                       v3: (.value.V3Score // null),
                                       v3_vector: (.value.V3Vector // null)})),
                         best_cvss:
                           (((.CVSS // {}) | to_entries
                             | map({source: .key,
                                    v3: (.value.V3Score // 0),
                                    v3_vector: (.value.V3Vector // null)})
                             | sort_by(-.v3) | .[0]) // {}),
                         cwe: (.CWEIDs // []),
                         title: .Title,
                         description: (.Description // null),
                         references: (.References // []),
                         published: (.PublishedDate // null),
                         modified: (.LastModifiedDate // null),
                         data_source: (.DataSource // {})
                       })
                   )
                 | add // [] );
             def sev_init: {"CRITICAL":0,"HIGH":0,"MEDIUM":0,"LOW":0,"UNKNOWN":0};
             def summarize($f):
               {
                 total: ($f | length),
                 by_severity: (reduce $f[] as $x (sev_init; .[$x.severity] += 1)),
                 fixable: {
                   total: ($f | map(select(.fix_available)) | length),
                   by_severity: (reduce ($f | map(select(.fix_available))[]) as $x (sev_init; .[$x.severity] += 1))
                 },
                 unique_vulns: ($f | map(.id) | unique | length),
                 packages_affected: ($f | map(.pkg) | unique | length),
                 highest_cvss_v3: ($f | map(.best_cvss.v3 // 0) | max // 0),
                 top_packages: (
                   $f | group_by(.pkg) | map({pkg: .[0].pkg, count: length}) | sort_by(-.count) | .[:10]
                 ),
                 by_target: (
                   $f | group_by(.target)
                      | map({
                          target: .[0].target,
                          total: length,
                          by_severity: (reduce .[] as $x (sev_init; .[$x.severity] += 1)),
                          fixable: (map(select(.fix_available)) | length)
                        })
                 )
               };
             def policy_hints($f):
               {
                 has_critical: any($f[]; .severity=="CRITICAL"),
                 has_high_without_fix: any($f[]; .severity=="HIGH" and (.fix_available|not)),
                 oldest_published_days:
                   ( if ($f|length)==0 then null
                     else ( [ $f[] | select(.published!=null) | (.published | fromdateiso8601) ]
                            | (if length>0 then min else now end) as $min
                            | (now - $min) / 86400 | floor )
                     end )
               };
             (to_findings) as $F
             |
             {
               meta: { repo: $repo, sha: $sha, ref: $ref, run_id: $run_id, run_url: $run_url, generated_at: $ts },
               scan: { tool: "trivy", tool_version: $trivy_version, mode: "fs", schema: "custom:v2" },
               summary: summarize($F),
               policy_hints: policy_hints($F),
               findings: $F
             }' > agent_payload.json

      # 4) Publica el payload y el JSON bruto como artefacto
      - name: Upload artifact (payload para IA)
        uses: actions/upload-artifact@v4
        with:
          name: trivy-payload
          path: |
            agent_payload.json
            trivy.json
          retention-days: 14
