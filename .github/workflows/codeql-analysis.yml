name: CodeQL Analysis

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 2 * * 0'

jobs:
  analyze:
    name: CodeQL Analysis
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write
    strategy:
      fail-fast: false
      matrix:
        language: [ 'java' ]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: ${{ matrix.language }}
          build-mode: none

      # Ejecuta CodeQL y escribe SARIF localmente (además de subir a Code Scanning)
      - name: Perform CodeQL Analysis (write SARIF locally)
        uses: github/codeql-action/analyze@v3
        with:
          output: ${{ github.workspace }}/codeql-sarif

      # Sube el SARIF como artifact reutilizable
      - name: Upload SARIF artifact
        uses: actions/upload-artifact@v4
        with:
          name: codeql-sarif
          path: ${{ github.workspace }}/codeql-sarif/*.sarif
          retention-days: 14

      # Convierte SARIF -> payload compacto para IA (robusto, sin problemas de quoting)
      - name: Build AI-friendly payload from SARIF
        shell: bash
        run: |
          set -euo pipefail

          RUN_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          TS=$(date -u +%FT%TZ)

          shopt -s nullglob
          SARIFS=("$GITHUB_WORKSPACE/codeql-sarif"/*.sarif)
          if [ ${#SARIFS[@]} -eq 0 ]; then
            # Payload vacío pero válido
            jq -n \
              --arg repo "${{ github.repository }}" \
              --arg sha "${{ github.sha }}" \
              --arg ref "${{ github.ref }}" \
              --arg run_id "${{ github.run_id }}" \
              --arg run_url "$RUN_URL" \
              --arg ts "$TS" \
              --arg lang "${{ matrix.language }}" \
              '{meta:{repo:$repo,sha:$sha,ref:$ref,run_id:$run_id,run_url:$run_url,generated_at:$ts},
                scan:{engine:"codeql",language:$lang,schema:"agent-payload:v1"},
                summary:{total:0,by_security_severity:{critical:0,high:0,medium:0,low:0,unknown:0},by_level:{error:0,warning:0,note:0,none:0},unique_rules:0,top_rules:[],by_file:[]},
                findings:[]}' \
              > codeql_agent_payload.json
          else
            SARIF_FILE="${SARIFS[0]}"

            # Guardamos el programa jq en un archivo mediante heredoc con comillas literales
            cat > program.jq <<'JQ'
def all_runs: ($sarif[0].runs // []);
def rules_index: ( [ all_runs[]?.tool?.driver?.rules[]? ] | INDEX(.id) );
def all_results: [ all_runs[]?.results[]? ];

def secsev($r; $ri):
  ( $r.properties["security-severity"]
    // $ri[$r.ruleId].properties["security-severity"]
    // "unknown" ) | ascii_downcase;

def toFinding($ri):
  {
    rule_id: .ruleId,
    rule_name: ($ri[.ruleId].name // $ri[.ruleId].shortDescription.text // null),
    security_severity: (secsev(.; $ri)),
    level: (.level // "warning"),
    message: (.message.text // null),
    file: (.locations[0].physicalLocation.artifactLocation.uri // null),
    startLine: (.locations[0].physicalLocation.region.startLine // null),
    startColumn: (.locations[0].physicalLocation.region.startColumn // null),
    help: ($ri[.ruleId].helpUri // null),
    rule_tags: ($ri[.ruleId].properties.tags // []),
    fingerprints: (.fingerprints // {})
  };

def sev_init: {"critical":0,"high":0,"medium":0,"low":0,"unknown":0};
def lvl_init: {"error":0,"warning":0,"note":0,"none":0};

(rules_index) as $RI
| (all_results) as $R
| ($R | map(toFinding($RI))) as $F
| {
    meta: {
      repo: $repo, sha: $sha, ref: $ref,
      run_id: $run_id, run_url: $run_url,
      generated_at: $ts
    },
    scan: { engine: "codeql", language: $lang, schema: "agent-payload:v1" },
    summary: {
      total: ($F | length),
      by_security_severity:
        (reduce $F[] as $x (sev_init; .[($x.security_severity // "unknown")] += 1)),
      by_level:
        (reduce $F[] as $x (lvl_init; .[($x.level // "warning")] += 1)),
      unique_rules: ($F | map(.rule_id) | unique | length),
      top_rules:
        ($F | group_by(.rule_id)
            | map({rule_id: .[0].rule_id, count: length})
            | sort_by(-.count) | .[:10]),
      by_file:
        ($F | group_by(.file)
            | map({file: (.[0].file // "<unknown>"), count: length})
            | sort_by(-.count) | .[:10])
    },
    findings: $F
  }
JQ

            jq -n \
              --arg repo "${{ github.repository }}" \
              --arg sha "${{ github.sha }}" \
              --arg ref "${{ github.ref }}" \
              --arg run_id "${{ github.run_id }}" \
              --arg run_url "$RUN_URL" \
              --arg ts "$TS" \
              --arg lang "${{ matrix.language }}" \
              --slurpfile sarif "$SARIF_FILE" \
              -f program.jq > codeql_agent_payload.json
          fi

          echo "Wrote codeql_agent_payload.json"
          jq -r '.summary' codeql_agent_payload.json || true

      # Sube el payload compacto como artefacto para el job de IA
      - name: Upload CodeQL agent payload
        uses: actions/upload-artifact@v4
        with:
          name: codeql-agent-payload
          path: codeql_agent_payload.json
          retention-days: 14
